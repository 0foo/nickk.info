<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-10-13T13:31:14+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">mysite</title><entry><title type="html">Working around API request limits with bulk IP proxy</title><link href="http://localhost:4000/2023/11/16/api-limits.html" rel="alternate" type="text/html" title="Working around API request limits with bulk IP proxy" /><published>2023-11-16T12:06:00+00:00</published><updated>2023-11-16T12:06:00+00:00</updated><id>http://localhost:4000/2023/11/16/api-limits</id><content type="html" xml:base="http://localhost:4000/2023/11/16/api-limits.html"><![CDATA[*( Note: this post is purely for experimentation and learning purposes. Sites have rate limits specifically to avoid data collection, because their data is propietary and core to their business. Additionally, on smaller sites especially, excessive scraping can DDOS the site and cause expensive resource utilization. Please respect a web site's wishes. )*
<br/><br/>

Most websites have API request limits __based on IP__ which make scraping or bulk data collection on their sites prohibitive.

Scraping and data collection requires a LOT of requests for each new page of data which would be rather quickly rate limited, slowing down your data collection to unsatisfactory speeds.

So what's the solution?  Send each request through a unique IP! 

There exists companies which specialize in Bulk IP proxying, and have bulk amounts of IP's, which, for a small fee, will let you proxy all of your requests through their network which, if all goes well, should give you unique IP per request goodness.

I found one of these IP providers called IPRoyal.

IPRoyal claims to have a network of 8 million residential IP's!!! 

I signed up for IPRoyal and forked over the 7 bucks to see what happens.

<!--more-->

<hr class="article-separator-more"/>


To begin, let's run a non-proxied reddit.com query with a curl statment to see how quickly we get rate limited. 

As everyone knows, 200 status code is a successful request and 429 status code is a blocked reqest due to rate limit. 

Let's see if we will get blocked by reddit.

(Note: These are async responses, so the responses are unordered. Had to async these for speed. )
```bash
nick@nick-XPS-9315:~$ for i in {1..1000}; do /bin/bash -c 'curl  -sL -o /dev/null -w "%{http_code} " https://www.reddit.com &'; done;
nick@nick-XPS-9315:~$ 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 200 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 429 200 429 429 429 429 429 429 429 429 429 429 429 429 429 429 200 429 429 200 429 200 200 429 200 200 200 429 200 429 429 200 429 200 200 200 429 429 200 429 200 200 200 429....
```


Rate limited almost immediately lol.

<hr class="article-separator-more"/>

So let's try with the IPRoyal network.

So, for 7 bucks IPRoyal gives you 1gig worth of data. 

To use their network you are provided with a hash/url combo which you can configure as a proxy via proxy application or combine for curl.

Now let's try with the IPRoyal proxy. :) (-x being the curl proxy flag)




```bash
IPRoyalProxy="http://<someBigHash>@geo.iproyal.com:12321"
nick@nick-XPS-9315:~$ for i in {1..1000}; do /bin/bash -c "curl  -s -o /dev/null -w \"%{http_code} \" -I -x $IPRoyalProxy -L https://www.reddit.com &"; done;
nick@nick-XPS-9315:~$ 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 000 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 200 .....
```

<br/>
Not a single 429!!   
IPRoyal is working as advertised.  
In the next post we're going to combine this with some sort of scraper or web spider to try and scrape all of the comment's of a Reddit user.]]></content><author><name></name></author><category term="networking" /><summary type="html"><![CDATA[( Note: this post is purely for experimentation and learning purposes. Sites have rate limits specifically to avoid data collection, because their data is propietary and core to their business. Additionally, on smaller sites especially, excessive scraping can DDOS the site and cause expensive resource utilization. Please respect a web site’s wishes. )]]></summary></entry><entry><title type="html">Weather Data Mining</title><link href="http://localhost:4000/2023/09/06/weather-data-mining.html" rel="alternate" type="text/html" title="Weather Data Mining" /><published>2023-09-06T12:16:00+00:00</published><updated>2023-09-06T12:16:00+00:00</updated><id>http://localhost:4000/2023/09/06/weather-data-mining</id><content type="html" xml:base="http://localhost:4000/2023/09/06/weather-data-mining.html"><![CDATA[In order to find places to live or visit where I can maximize the amount of time I'm able to comfortably spend outside I wrote a script to calculate the locations in the US with temperatures between 30 degrees and 75 degrees for 6 months or more.
<br/><br/>

* All the data comes from NOAA weather stations and can be downloaded here: [link](https://www.ncei.noaa.gov/pub/data/ghcn/daily/)
* The github repo is here: [https://github.com/0foo/weather_mining](https://github.com/0foo/weather_mining)
* The interactive google map is here: [link](https://www.google.com/maps/d/edit?mid=11qYJOQ2cX9j3T-x5UO5ykXmjUToSdEs&ll=42.70028862623725%2C-119.24163318010127&z=7)
<br/><br/>


 <!--more-->


<u>Interesting observations:</u>

* Looks like the crown for perfect temps year round goes to the Pacific Northwest including northern California, Oregon, and Washington.  Many locations there have perfect temps 12 months out of the year.

* The entire West coast fared really well with most of it experiencing comfortable temps most of the year with a few months slightly deviating into cold or hot.

* There's a swath of the southeastern part of the country that has more than 6 months of comfortable temps that curves up the east coast, however almost all of the east/southeast locations cap out at 7 or 8 months of comfortable temps, which doesn't reach west coast comfort levels of 8+ months typically. 

<br/>

<u>To Do (when have time) </u>
* At some point would like to convert this to a dynamic site where you can plot migration patterns to stay in comfortable weather for traveling retired or digital nomads. 
* Would like to be able to dynamically input your own custom comfortable temp ranges as peoples idea of comfortable temps and temp tolerances may vary.
* At some point would like to include other weather factors like sunshine, preciptation, snowfall

<br/><br/>

* Note: on this map the field labeled count is months within the comfort zone of 30 to 75.
<br/>
<iframe src="https://www.google.com/maps/d/embed?mid=11qYJOQ2cX9j3T-x5UO5ykXmjUToSdEs&ehbc=2E312F" width="100%" height="800"></iframe>]]></content><author><name></name></author><summary type="html"><![CDATA[In order to find places to live or visit where I can maximize the amount of time I’m able to comfortably spend outside I wrote a script to calculate the locations in the US with temperatures between 30 degrees and 75 degrees for 6 months or more. All the data comes from NOAA weather stations and can be downloaded here: link The github repo is here: https://github.com/0foo/weather_mining The interactive google map is here: link]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/noaa.jpeg" /><media:content medium="image" url="http://localhost:4000/noaa.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Terrible Implementations of Is Even</title><link href="http://localhost:4000/2023/09/05/is-even.html" rel="alternate" type="text/html" title="Terrible Implementations of Is Even" /><published>2023-09-05T12:06:00+00:00</published><updated>2023-09-05T12:06:00+00:00</updated><id>http://localhost:4000/2023/09/05/is-even</id><content type="html" xml:base="http://localhost:4000/2023/09/05/is-even.html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. <br/>
What a way to turn a O(1) modulus operation into the funny abomination you see here.  <br/>
This algorithm has a runtime of O(2^n). <br/>

<!--more-->

```python 
def is_even(num):
  x = abs(num)
  # x is even if it can be divided into two parts y and z that equal each other
  y,z = 0,0
  # take turns incrementing y and z
  for i in range(x):
    if is_even(i):
      y += 1
    else:
      z += 1
  return (y == z)
```

```
Runtime(x) = Runtime(x-1) + Runtime(x-2) + ... + Runtime(0)  
Runtime(x-1) = Runtime(x-2) + Runtime(x-3) + ... + Runtime(0)  
Runtime(x) = 2 * Runtime(x-1) = 2 * 2 * Runtime(x-2) = ... = 2 * 2 * 2 * ... * Runtime(0) = 2^x * const. 

```]]></content><author><name></name></author><category term="algorithms" /><summary type="html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. What a way to turn a O(1) modulus operation into the funny abomination you see here. This algorithm has a runtime of O(2^n).]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/20231102_081138.jpg" /><media:content medium="image" url="http://localhost:4000/20231102_081138.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Terrible Implementations of Is Even</title><link href="http://localhost:4000/2023/09/04/is-even.html" rel="alternate" type="text/html" title="Terrible Implementations of Is Even" /><published>2023-09-04T12:06:00+00:00</published><updated>2023-09-04T12:06:00+00:00</updated><id>http://localhost:4000/2023/09/04/is-even</id><content type="html" xml:base="http://localhost:4000/2023/09/04/is-even.html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. <br/>
What a way to turn a O(1) modulus operation into the funny abomination you see here.  <br/>
This algorithm has a runtime of O(2^n). <br/>

<!--more-->

```python 
def is_even(num):
  x = abs(num)
  # x is even if it can be divided into two parts y and z that equal each other
  y,z = 0,0
  # take turns incrementing y and z
  for i in range(x):
    if is_even(i):
      y += 1
    else:
      z += 1
  return (y == z)
```

```
Runtime(x) = Runtime(x-1) + Runtime(x-2) + ... + Runtime(0)  
Runtime(x-1) = Runtime(x-2) + Runtime(x-3) + ... + Runtime(0)  
Runtime(x) = 2 * Runtime(x-1) = 2 * 2 * Runtime(x-2) = ... = 2 * 2 * 2 * ... * Runtime(0) = 2^x * const. 

```]]></content><author><name></name></author><category term="algorithms" /><summary type="html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. What a way to turn a O(1) modulus operation into the funny abomination you see here. This algorithm has a runtime of O(2^n).]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/20231102_081138.jpg" /><media:content medium="image" url="http://localhost:4000/20231102_081138.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Terrible Implementations of Is Even</title><link href="http://localhost:4000/2023/09/02/is-even.html" rel="alternate" type="text/html" title="Terrible Implementations of Is Even" /><published>2023-09-02T12:06:00+00:00</published><updated>2023-09-02T12:06:00+00:00</updated><id>http://localhost:4000/2023/09/02/is-even</id><content type="html" xml:base="http://localhost:4000/2023/09/02/is-even.html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. <br/>
What a way to turn a O(1) modulus operation into the funny abomination you see here.  <br/>
This algorithm has a runtime of O(2^n). <br/>

<!--more-->

```python 
def is_even(num):
  x = abs(num)
  # x is even if it can be divided into two parts y and z that equal each other
  y,z = 0,0
  # take turns incrementing y and z
  for i in range(x):
    if is_even(i):
      y += 1
    else:
      z += 1
  return (y == z)
```

```
Runtime(x) = Runtime(x-1) + Runtime(x-2) + ... + Runtime(0)  
Runtime(x-1) = Runtime(x-2) + Runtime(x-3) + ... + Runtime(0)  
Runtime(x) = 2 * Runtime(x-1) = 2 * 2 * Runtime(x-2) = ... = 2 * 2 * 2 * ... * Runtime(0) = 2^x * const. 

```]]></content><author><name></name></author><category term="algorithms" /><summary type="html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. What a way to turn a O(1) modulus operation into the funny abomination you see here. This algorithm has a runtime of O(2^n).]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/20231102_081138.jpg" /><media:content medium="image" url="http://localhost:4000/20231102_081138.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Terrible Implementations of Is Even</title><link href="http://localhost:4000/2022/09/03/is-even.html" rel="alternate" type="text/html" title="Terrible Implementations of Is Even" /><published>2022-09-03T12:06:00+00:00</published><updated>2022-09-03T12:06:00+00:00</updated><id>http://localhost:4000/2022/09/03/is-even</id><content type="html" xml:base="http://localhost:4000/2022/09/03/is-even.html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. <br/>
What a way to turn a O(1) modulus operation into the funny abomination you see here.  <br/>
This algorithm has a runtime of O(2^n). <br/>

<!--more-->

```python 
def is_even(num):
  x = abs(num)
  # x is even if it can be divided into two parts y and z that equal each other
  y,z = 0,0
  # take turns incrementing y and z
  for i in range(x):
    if is_even(i):
      y += 1
    else:
      z += 1
  return (y == z)
```

```
Runtime(x) = Runtime(x-1) + Runtime(x-2) + ... + Runtime(0)  
Runtime(x-1) = Runtime(x-2) + Runtime(x-3) + ... + Runtime(0)  
Runtime(x) = 2 * Runtime(x-1) = 2 * 2 * Runtime(x-2) = ... = 2 * 2 * 2 * ... * Runtime(0) = 2^x * const. 

```]]></content><author><name></name></author><category term="algorithms" /><summary type="html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. What a way to turn a O(1) modulus operation into the funny abomination you see here. This algorithm has a runtime of O(2^n).]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/20231102_081138.jpg" /><media:content medium="image" url="http://localhost:4000/20231102_081138.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>