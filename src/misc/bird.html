<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pixi Bird • Side Hover, Smooth Takeoff, Branch Under Feet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; font-family: system-ui, sans-serif; }
    .wrap { max-width: 60ch; margin: 4rem auto; padding: 0 1rem; line-height: 1.55; }
    .spacer { height: 220vh; }
    #pixi-overlay { position: fixed; inset: 0; pointer-events: none; z-index: 9999; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Scroll to take off; bird hovers in side 30% only</h1>
    <p>Bird hovers in the left or right 30% bands (upper half), never in the center. Landing/takeoff use
       the same smooth spring. A branch grows under the feet, perfectly aligned.</p>
  </div>
  <div class="spacer"></div>

  <script src="https://unpkg.com/pixi.js@7.2.4/dist/pixi.min.js"></script>
  <canvas id="pixi-overlay"></canvas>
  <script>
    // -------------------- TUNABLES --------------------
    const SCROLL_TO_VEL = 0.18;            // px/s per px of scroll delta (kept tame)
    const MAX_VEL_Y = 220;                 // clamp vertical speed (px/s)
    const MAX_VEL_X = 220;                 // clamp horizontal speed (px/s)
    const DRAG = 0.92;                     // vertical damping per frame (0..1)

    const FLAP_SPEED_FLY = 6.0;
    const FLAP_SPEED_PERCH = 0.0;

    // Idle → landing behavior
    const NO_SCROLL_BEFORE_LAND_MS = 3500; // must be idle at least this long
    const EXTRA_LAND_DELAY_MS = 1500;      // additional delay before landing
    const LAND_DWELL_MS = 1400;            // dwell time after touchdown before takeoff allowed

    // Layout
    const EDGE_MARGIN = 24;
    const SIDE_BAND = 120;                 // landing band in from the screen edges
    const HOP_ON_LAND = 6;

    // Hover behavior (upper-half loiter in *side* 30% bands)
    const HOVER_SPRING = 5.0;              // spring gain toward target
    const HOVER_DAMP = 0.90;               // damping on velocity
    const HOVER_NOISE_Y = 0.16;            // subtle vertical bobbing
    const HOVER_NOISE_Y_SPEED = 1.6;       // Hz
    const HOVER_WANDER_RADIUS = 68;        // horizontal wander radius
    const HOVER_WANDER_SPEED = 0.22;       // orbits/sec
    const HOVER_JITTER_RADIUS = 6;         // small jitter

    // Landing movement uses the same model for consistent speed
    const LAND_SPRING = HOVER_SPRING;
    const LAND_DAMP   = HOVER_DAMP;

    // Legs / feet (longer)
    const LEG_LENGTH = 12;
    const LEG_THICK  = 3;
    const FOOT_LEN   = 6;

    // Smooth takeoff guard: ignore scroll-driven velocity injection right after takeoff
    const TAKEOFF_IGNORE_SCROLL_MS = 220;


    

    // -------------------- PIXI APP --------------------
    const view = document.getElementById('pixi-overlay');
    const app = new PIXI.Application({
      view,
      resizeTo: window,
      backgroundAlpha: 0,
      antialias: true,
      powerPreference: 'high-performance',
    });
    app.stage.sortableChildren = true;

    const rand = (a, b) => a + Math.random() * (b - a);
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    // -------------------- BRANCH --------------------
// Branch size & growth
const BRANCH_LENGTH = 216;   // was ~180; now 20% longer
const BRANCH_THICK  = 12;
const BRANCH_GROW_SPEED = 2.5;
const BRANCH_RETRACT_SPEED = 3.0;

// Angle (inward, with a slight preference upward)
const BRANCH_ANGLE_UP_DEG   = 18;
const BRANCH_ANGLE_DOWN_DEG = 12;
const BRANCH_ANGLE_BIAS_UP  = 0.65;

// Random bends only in the *second half*
const BRANCH_KINKS_MIN   = 2;
const BRANCH_KINKS_MAX   = 4;
const BRANCH_KINK_AMP    = 10;     // raise for wilder bends (e.g., 16–22)
const BRANCH_TAPER_POWER = 1.25;   // tip tapering

// --- Drop-in replacement Branch class ---
class Branch extends PIXI.Container {
  constructor() {
    super();
    this.side = 'right';         // 'left' | 'right'
    this.progress = 0;           // 0..1 reveal amount
    this.targetProgress = 0;
    this.len = BRANCH_LENGTH;
    this.angleOffsetRad = 0;

    // We reveal by scaling the inner graphics on X (bulletproof with rotation)
    this.graphics = new PIXI.Graphics();
    this.addChild(this.graphics);
    this.graphics.position.set(0, 0);
    this.graphics.pivot.set(0, 0);
    this.graphics.scale.set(0, 1); // start hidden

    this.zIndex = 1;
    this._buildRandomShape();
    this._placeAtEdge();
  }

  show(side) {
    this.side = side;

    // Random inward tilt (bias upward)
    const tiltUp = Math.random() < BRANCH_ANGLE_BIAS_UP;
    const deg = tiltUp
      ? -(Math.random() * BRANCH_ANGLE_UP_DEG)   // negative = tilt up
      :  (Math.random() * BRANCH_ANGLE_DOWN_DEG);
    this.angleOffsetRad = deg * Math.PI / 180;

    this._buildRandomShape();  // new back-half bends each landing
    this._placeAtEdge();
    this.targetProgress = 1;
  }

  hide() { this.targetProgress = 0; }

  _placeAtEdge() {
    const w = app.renderer.width;
    if (this.side === 'right') {
      this.x = w;
      this.rotation = Math.PI + this.angleOffsetRad; // inward (left)
    } else {
      this.x = 0;
      this.rotation = 0 + this.angleOffsetRad;       // inward (right)
    }
  }

  // First half: perfectly straight “platform”
  // Second half: random kinks with taper, pointed tip, solid black
  _buildRandomShape() {
  const g = this.graphics;
  g.clear();

  const L = this.len;
  const straightEnd = L * 0.5; // first 50% must be perfectly straight

  // Spine x positions: start, straight midpoint, (kinks only in back half), tip
  const xs = [0, straightEnd];
  const kinkCount = Math.floor(Math.random() * (BRANCH_KINKS_MAX - BRANCH_KINKS_MIN + 1)) + BRANCH_KINKS_MIN;
  for (let i = 0; i < kinkCount; i++) {
    // Constrain kinks strictly to the back half
    xs.push(L * (0.55 + 0.35 * Math.random()));
  }
  xs.push(L);
  xs.sort((a, b) => a - b);

  // Perpendicular offsets (y) for spine
  const ys = xs.map((x) => {
    if (x <= straightEnd) return 0; // perfectly straight in first half
    if (x >= L) return 0;           // keep tip centered for a clean point
    return (Math.random() * 2 - 1) * BRANCH_KINK_AMP;
  });

  // Width profile: CONSTANT in first half; taper only after straightEnd → tip
  const widths = xs.map(x => {
    if (x <= straightEnd) return BRANCH_THICK;
    const t = (x - straightEnd) / (L - straightEnd);         // 0..1 over back half
    const taper = Math.pow(1 - t, BRANCH_TAPER_POWER);       // 1→0 on back half
    return Math.max(0, BRANCH_THICK * taper);
  });

  // Build polygon around spine by offsetting ±(width/2) along a normal
  const upper = [];
  const lower = [];
  for (let i = 0; i < xs.length; i++) {
    const x = xs[i], y = ys[i], wHalf = widths[i] * 0.5;

    // Tangent from neighboring points to get a stable normal
    const iPrev = Math.max(0, i - 1);
    const iNext = Math.min(xs.length - 1, i + 1);
    const tx = xs[iNext] - xs[iPrev];
    const ty = ys[iNext] - ys[iPrev];
    const mag = Math.max(1e-6, Math.hypot(tx, ty));
    const nx = -ty / mag, ny = tx / mag; // unit normal

    upper.push([x + nx * wHalf, y + ny * wHalf]);
    lower.push([x - nx * wHalf, y - ny * wHalf]);
  }

  // Solid black shape
  g.beginFill(0x000000, 1);
  g.moveTo(upper[0][0], upper[0][1]);
  for (let i = 1; i < upper.length; i++) g.lineTo(upper[i][0], upper[i][1]);
  for (let i = lower.length - 1; i >= 0; i--) g.lineTo(lower[i][0], lower[i][1]);
  g.closePath();
  g.endFill();

  // Extra pointed tip (small triangle)
  const tipX = xs[xs.length - 1], tipY = ys[ys.length - 1];
  g.beginFill(0x000000, 1);
  g.moveTo(tipX, tipY);
  g.lineTo(tipX - 12, tipY - 4);
  g.lineTo(tipX - 12, tipY + 4);
  g.closePath();
  g.endFill();

  // Maintain current reveal amount
  g.scale.x = this.progress;
  this.visible = this.progress > 0.001;
}


  update(dt) {
    const speed = (this.targetProgress > this.progress) ? BRANCH_GROW_SPEED : BRANCH_RETRACT_SPEED;
    const dir = Math.sign(this.targetProgress - this.progress);
    if (dir !== 0) {
      this.progress += dir * speed * dt;
      if ((dir > 0 && this.progress > this.targetProgress) ||
          (dir < 0 && this.progress < this.targetProgress)) {
        this.progress = this.targetProgress;
      }
      this.graphics.scale.x = this.progress;   // reveal from the root
      this.visible = this.progress > 0.001;
    }
  }
}





    // -------------------- BIRD --------------------
    class Bird extends PIXI.Container {
      constructor() {
        super();
        this.state = 'perched'; // 'perched' | 'hovering' | 'landing'
        this.vx = 0;
        this.vy = 0;
        this.flapPhase = 0;

        this.hoverTarget = { x: 0, y: 0 };
        this.landTarget  = { x: 0, y: 0 };
        this.lastLandingSide = 'right';
        this.wanderTheta = Math.random() * Math.PI * 2;
        this.landDwellUntil = 0;
        this.takeoffIgnoreUntil = 0;

        // Parts
        this.body = new PIXI.Graphics();
        this.leftWing = new PIXI.Graphics();
        this.rightWing = new PIXI.Graphics();
        this._drawBody();
        this._drawWing(this.leftWing);
        this._drawWing(this.rightWing);
        this.addChild(this.leftWing, this.rightWing, this.body);
        this.rightWing.scale.x = -1;
        this.leftWing.position.set(-10, -6);
        this.rightWing.position.set(10, -6);
        this.legs.visible = false;

        this.scale.set(1.2);
        this.zIndex = 2;

        // Start perched near lower-right
        this.position.set(app.renderer.width - SIDE_BAND, app.renderer.height * 0.75);
      }

      _drawBody() {
        const g = this.body;
        g.clear();
        g.lineStyle(2, 0x222222, 1);
        g.beginFill(0x334455, 1); g.drawEllipse(0, 0, 16, 10); g.endFill();
        g.beginFill(0x445566, 1); g.drawCircle(14, -6, 6); g.endFill();
        g.beginFill(0xD99911, 1);
        g.moveTo(20, -6); g.lineTo(28, -4); g.lineTo(20, -2); g.closePath(); g.endFill();

        // legs + tiny feet (longer)
        if (this.legs) this.removeChild(this.legs);
        this.legs = new PIXI.Graphics();
        this.legs.lineStyle(LEG_THICK, 0x3a2208, 1);

        // Left leg
        this.legs.moveTo(-3, 10);
        this.legs.lineTo(-3, 10 + LEG_LENGTH);
        // toes
        this.legs.moveTo(-3, 10 + LEG_LENGTH);
        this.legs.lineTo(-3 - FOOT_LEN, 10 + LEG_LENGTH + 2);
        this.legs.moveTo(-3, 10 + LEG_LENGTH);
        this.legs.lineTo(-3 + FOOT_LEN, 10 + LEG_LENGTH + 2);

        // Right leg
        this.legs.moveTo(3, 10);
        this.legs.lineTo(3, 10 + LEG_LENGTH);
        // toes
        this.legs.moveTo(3, 10 + LEG_LENGTH);
        this.legs.lineTo(3 - FOOT_LEN, 10 + LEG_LENGTH + 2);
        this.legs.moveTo(3, 10 + LEG_LENGTH);
        this.legs.lineTo(3 + FOOT_LEN, 10 + LEG_LENGTH + 2);

        this.addChild(this.legs);
      }

      _drawWing(wing) {
        wing.clear();
        wing.lineStyle(2, 0x222222, 1);
        wing.beginFill(0x556677, 1);
        wing.moveTo(0, 0);
        wing.quadraticCurveTo(-18, -6, -26, -2);
        wing.quadraticCurveTo(-14, 6, 0, 0);
        wing.endFill();
        wing.pivot.set(-2, 0);
      }

      setState(next) {
        if (this.state === next) return;
        this.state = next;
        if (next === 'perched') {
          this.vx = 0; this.vy = 0;
          this.legs.visible = true;
          this.landDwellUntil = performance.now() + LAND_DWELL_MS;
        } else {
          this.legs.visible = false;
        }
      }

      // Side 30% bands only: left 0–30% or right 70–100% (never center)
      _randSideBandX() {
        const w = app.renderer.width;
        const leftMax = w * 0.30 - EDGE_MARGIN;
        const rightMin = w * 0.70 + EDGE_MARGIN;
        return (Math.random() < 0.5)
          ? rand(EDGE_MARGIN + 60, Math.max(EDGE_MARGIN + 61, leftMax))
          : rand(Math.min(w - EDGE_MARGIN - 60, rightMin), w - EDGE_MARGIN - 60);
      }

      chooseRandomUpperHalfHover() {
        const h = app.renderer.height;
        this.hoverTarget.x = this._randSideBandX();
        this.hoverTarget.y = rand(EDGE_MARGIN, Math.max(EDGE_MARGIN + 1, h * 0.5 - EDGE_MARGIN));
        this.wanderTheta = Math.random() * Math.PI * 2;
      }

      chooseRandomUpperHalfSideLanding() {
        const w = app.renderer.width, h = app.renderer.height;
        const onRight = Math.random() < 0.5;
        this.lastLandingSide = onRight ? 'right' : 'left';
        this.landTarget.x = onRight
          ? Math.max(w - SIDE_BAND, w - EDGE_MARGIN - 40)
          : Math.min(SIDE_BAND, EDGE_MARGIN + 40);
        this.landTarget.y = rand(EDGE_MARGIN, Math.max(EDGE_MARGIN + 1, h * 0.5 - EDGE_MARGIN));
      }

      // Gentle nudge on takeoff (no snapping that causes a spike)
      gentleNudgeTowardHover(amount = 0.15) {
        this.x += (this.hoverTarget.x - this.x) * amount;
        this.y += (this.hoverTarget.y - this.y) * amount;
        this.vx = 0; this.vy = 0; // start with calm velocities
      }

      _applySpringTo(targetX, targetY, k, damp, dt) {
        const dx = targetX - this.x;
        const dy = targetY - this.y;

        this.vx = (this.vx + dx * k * dt) * damp;
        this.vy = (this.vy + dy * k * dt) * damp;

        // Clamp
        this.vx = clamp(this.vx, -MAX_VEL_X, MAX_VEL_X);
        this.vy = clamp(this.vy, -MAX_VEL_Y, MAX_VEL_Y);

        this.x += this.vx * dt;
        this.y += this.vy * dt;
      }

      feetY() {
        // Body center y + leg offset + length
        return this.y + 10 + LEG_LENGTH;
      }

      update(dtMs) {
        const dt = dtMs / 1000;
        const t = performance.now() / 1000;

        // Wings
        const flapSpeed = this.state === 'perched' ? FLAP_SPEED_PERCH : FLAP_SPEED_FLY;
        this.flapPhase += flapSpeed * dt * Math.PI * 2;
        const flap = Math.sin(this.flapPhase) * (this.state === 'landing' ? 0.35 : 0.75);
        this.leftWing.rotation  = -0.4 + flap * 0.5;
        this.rightWing.rotation =  0.4 - flap * 0.5;

        if (this.state === 'hovering') {
          // Side-band wander around hoverTarget.x
          this.wanderTheta += HOVER_WANDER_SPEED * dt * Math.PI * 2;
          const wanderX = this.hoverTarget.x + Math.cos(this.wanderTheta) * HOVER_WANDER_RADIUS;
          const jitterX = (Math.random() - 0.5) * HOVER_JITTER_RADIUS;
          const jitterY = (Math.random() - 0.5) * HOVER_JITTER_RADIUS * 0.6;
          const targetX = wanderX + jitterX;
          const targetY = this.hoverTarget.y + jitterY + Math.sin(t * HOVER_NOISE_Y_SPEED * 2 * Math.PI) * HOVER_NOISE_Y;

          this._applySpringTo(targetX, targetY, HOVER_SPRING, HOVER_DAMP, dt);

          // Keep on screen vertically
          const minY = EDGE_MARGIN, maxY = app.renderer.height - EDGE_MARGIN;
          this.y = Math.max(minY, Math.min(maxY, this.y));

          // Light damping on scroll-driven vy
          this.vy *= DRAG;

        } else if (this.state === 'landing') {
          // Same spring/damp as hover → consistent speed
          this._applySpringTo(this.landTarget.x, this.landTarget.y, LAND_SPRING, LAND_DAMP, dt);

          // Touchdown check
          if (Math.hypot(this.landTarget.x - this.x, this.landTarget.y - this.y) < 2) {
            this.position.set(this.landTarget.x, this.landTarget.y - HOP_ON_LAND);
            this.setState('perched');
            branch.show(this.lastLandingSide);
          }

        } else if (this.state === 'perched') {
          // tiny settle hop
          if (this.position.y < this.landTarget.y) {
            this.position.y = Math.min(this.landTarget.y, this.position.y + 40 * dt);
          }
        }
      }
    }

    // Layering: branch (z=1), bird (z=2)
    const branch = new Branch();
    const bird = new Bird();
    app.stage.addChild(branch, bird);

    // -------------------- INPUT / IDLE LOGIC --------------------
    let lastScrollY = window.scrollY;
    let lastScrollT = performance.now();
    let idlePrimaryTimer = null;
    let idleSecondaryTimer = null;

    function clearIdleTimers() {
      if (idlePrimaryTimer) { clearTimeout(idlePrimaryTimer); idlePrimaryTimer = null; }
      if (idleSecondaryTimer) { clearTimeout(idleSecondaryTimer); idleSecondaryTimer = null; }
    }

    function beginIdleCountdown() {
      clearIdleTimers();
      idlePrimaryTimer = setTimeout(() => {
        idleSecondaryTimer = setTimeout(() => {
          bird.chooseRandomUpperHalfSideLanding();
          bird.setState('landing');
          // Prep branch (y set continuously under feet in the ticker)
          branch.hide();
          branch.side = bird.lastLandingSide;
          branch._placeAtEdge();
        }, EXTRA_LAND_DELAY_MS);
      }, NO_SCROLL_BEFORE_LAND_MS);
    }

    function onScrollDelta(dy) {
      const now = performance.now();

      // Respect landing dwell
      if (bird.state === 'perched' && now < bird.landDwellUntil) return;

      const dt = Math.max(1, now - lastScrollT);
      lastScrollT = now;

      // Map scroll to vertical velocity (then clamp)
      const rawVy = (dy / (dt / 1000)) * SCROLL_TO_VEL;
      const clampedVy = clamp(rawVy, -MAX_VEL_Y, MAX_VEL_Y);

      if (bird.state === 'perched' || bird.state === 'landing') {
        // TAKEOFF: retract branch and start hovering, gently
        branch.hide();
        bird.chooseRandomUpperHalfHover();
        bird.gentleNudgeTowardHover(0.15);
        bird.setState('hovering');
        bird.takeoffIgnoreUntil = now + TAKEOFF_IGNORE_SCROLL_MS;
      }

      if (bird.state === 'hovering') {
        // During the first ~200ms after takeoff, ignore scroll-velocity injection to avoid jerk
        if (now > bird.takeoffIgnoreUntil) {
          bird.vy = bird.vy * 0.3 + clampedVy * 0.7;
          bird.vy = clamp(bird.vy, -MAX_VEL_Y, MAX_VEL_Y);
        }
      }

      beginIdleCountdown();
    }

    window.addEventListener('scroll', () => {
      const y = window.scrollY;
      const dy = y - lastScrollY;
      lastScrollY = y;
      onScrollDelta(dy);
    }, { passive: true });

    window.addEventListener('wheel', (e) => {
      onScrollDelta(e.deltaY);
    }, { passive: true });

    beginIdleCountdown();

    // -------------------- TICK --------------------
    let lastT = performance.now();
    app.ticker.add(() => {
      const now = performance.now();
      const dt = (now - lastT) / 1000; lastT = now;

      // Keep the branch exactly under the toes while landed/landing
      if (bird.state === 'landing' || bird.state === 'perched') {
        branch.y = bird.feetY() + 2; // +2 = tiny overlap so toes "sit" on wood
      }
      branch.update(dt);
      bird.update(dt * 1000);
    });

    window.addEventListener('resize', () => {
      branch._placeAtEdge();
      // If hovering, pick a new side-band hover point (still upper half)
      if (bird.state === 'hovering') {
        bird.chooseRandomUpperHalfHover();
        bird.gentleNudgeTowardHover(0.12);
      }
    });
  </script>
</body>
</html>
