<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2023-11-15T20:13:44+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Weather Data Mining</title><link href="http://0.0.0.0:4000/2023/09/06/weather-data-mining.html" rel="alternate" type="text/html" title="Weather Data Mining" /><published>2023-09-06T12:16:00+00:00</published><updated>2023-09-06T12:16:00+00:00</updated><id>http://0.0.0.0:4000/2023/09/06/weather-data-mining</id><content type="html" xml:base="http://0.0.0.0:4000/2023/09/06/weather-data-mining.html"><![CDATA[<p>In order to find places to live or visit where I can maximize the amount of time I’m able to comfortably spend outside I wrote a script to calculate the locations in the US with temperatures between 30 degrees and 75 degrees for 6 months or more.
<br /><br /></p>

<ul>
  <li>All the data comes from NOAA weather stations and can be downloaded here: <a href="https://www.ncei.noaa.gov/pub/data/ghcn/daily/">link</a></li>
  <li>The github repo is here: <a href="https://github.com/0foo/weather_mining">https://github.com/0foo/weather_mining</a></li>
  <li>The interactive google map is here: <a href="https://www.google.com/maps/d/edit?mid=11qYJOQ2cX9j3T-x5UO5ykXmjUToSdEs&amp;ll=42.70028862623725%2C-119.24163318010127&amp;z=7">link</a>
<br /><br /></li>
</ul>

<p><!--more--></p>

<p><u>Interesting observations:</u></p>

<ul>
  <li>
    <p>Looks like the crown for perfect temps year round goes to the Pacific Northwest including northern California, Oregon, and Washington.  Many locations there have perfect temps 12 months out of the year.</p>
  </li>
  <li>
    <p>The entire West coast fared really well with most of it experiencing comfortable temps most of the year with a few months slightly deviating into cold or hot.</p>
  </li>
  <li>
    <p>There’s a swath of the southeastern part of the country that has more than 6 months of comfortable temps that curves up the east coast, however almost all of the east/southeast locations cap out at 7 or 8 months of comfortable temps, which doesn’t reach west coast comfort levels of 8+ months typically.</p>
  </li>
</ul>

<p><br /></p>

<p><u>To Do (when have time) </u></p>
<ul>
  <li>At some point would like to convert this to a dynamic site where you can plot migration patterns to stay in comfortable weather for traveling retired or digital nomads.</li>
  <li>Would like to be able to dynamically input your own custom comfortable temp ranges as peoples idea of comfortable temps and temp tolerances may vary.</li>
  <li>At some point would like to include other weather factors like sunshine, preciptation, snowfall</li>
</ul>

<p><br /><br /></p>

<ul>
  <li>Note: on this map the field labeled count is months within the comfort zone of 30 to 75.
<br /></li>
</ul>
<iframe src="https://www.google.com/maps/d/embed?mid=11qYJOQ2cX9j3T-x5UO5ykXmjUToSdEs&amp;ehbc=2E312F" width="100%" height="800"></iframe>]]></content><author><name></name></author><summary type="html"><![CDATA[In order to find places to live or visit where I can maximize the amount of time I’m able to comfortably spend outside I wrote a script to calculate the locations in the US with temperatures between 30 degrees and 75 degrees for 6 months or more. All the data comes from NOAA weather stations and can be downloaded here: link The github repo is here: https://github.com/0foo/weather_mining The interactive google map is here: link]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://0.0.0.0:4000/noaa.jpeg" /><media:content medium="image" url="http://0.0.0.0:4000/noaa.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Terrible Implementations of Is Even</title><link href="http://0.0.0.0:4000/2023/09/02/is-even.html" rel="alternate" type="text/html" title="Terrible Implementations of Is Even" /><published>2023-09-02T12:06:00+00:00</published><updated>2023-09-02T12:06:00+00:00</updated><id>http://0.0.0.0:4000/2023/09/02/is-even</id><content type="html" xml:base="http://0.0.0.0:4000/2023/09/02/is-even.html"><![CDATA[<p>I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. <br />
What a way to turn a O(1) modulus operation into the glorious abomination you see here.  <br />
This algorithm has a runtime of O(2^n). <br /></p>

<!--more-->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
  <span class="n">x</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
  <span class="c1"># x is even if it can be divided into two parts y and z that equal each other
</span>  <span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
  <span class="c1"># take turns incrementing y and z
</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">is_even</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
      <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">z</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="nf">return </span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">z</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Runtime(x) = Runtime(x-1) + Runtime(x-2) + ... + Runtime(0)  
Runtime(x-1) = Runtime(x-2) + Runtime(x-3) + ... + Runtime(0)  
Runtime(x) = 2 * Runtime(x-1) = 2 * 2 * Runtime(x-2) = ... = 2 * 2 * 2 * ... * Runtime(0) = 2^x * const. 

</code></pre></div></div>]]></content><author><name></name></author><category term="algorithms" /><summary type="html"><![CDATA[I stumbled on this written as a joke somewhere on the web and found it hilariously terrible. What a way to turn a O(1) modulus operation into the glorious abomination you see here. This algorithm has a runtime of O(2^n).]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://0.0.0.0:4000/20231102_081138.jpg" /><media:content medium="image" url="http://0.0.0.0:4000/20231102_081138.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>